/*
 * Copyright (c) 2020, Vladislav Yaroshchuk <yaroshchuk2000@gmail.com>
 * Copyright (c) 2012, Bei Guan <gbtju85@gmail.com>
 * Copyright (c) 2008 - 2012, Intel Corporation. All rights reserved.<BR>
 *
 * SPDX-License-Identifier: BSD-2-Clause-Patent
 */

#include "AcpiPlatform.h"

#include <Library/BaseMemoryLib.h>
#include <Library/MemoryAllocationLib.h>

#define XHYVE_ACPI_BASE    0xf2400

/**
  Get Xhyve ACPI Root System Description Pointer address

  @param   RsdpBase           Get pointer to RSDP table

  @returns EFI_SUCCESS        Xhyve RSDP structure found successfully
  @returns EFI_NOT_FOUND      Xhyve RSDP structure not found
**/
EFI_STATUS
EFIAPI
GetXhyveAcpiRsdp(
    OUT EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER **RsdpBase
  )
{
  EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER    *RsdpPtr;
  UINT8                                           Checksum;

  RsdpPtr = (EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER *) XHYVE_ACPI_BASE;
  if (AsciiStrnCmp((CHAR8*) &RsdpPtr->Signature, "RSD PTR ", 8)) {
    return EFI_ABORTED;
  }

  Checksum = CalculateSum8(
      (CONST UINT8 *)RsdpPtr,
      sizeof(EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER)
  );


  if (Checksum != 0) {
    return EFI_ABORTED;
  }

  if (RsdpPtr->Revision == 2) {
      Checksum = CalculateSum8(
        (CONST UINT8 *)RsdpPtr,
        sizeof(EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER)
    );

    if (Checksum != 0) {
      return EFI_ABORTED;
    }
  }
  
  *RsdpBase = RsdpPtr;

  return EFI_SUCCESS;
}

/**
  Try to find ACPI tables generated by Xhyve and install them. Based
  on InstallXenTables()

  @param    AcpiTable       Protocol instance pointer

  @returns  EFI_SUCCESS     When installation complete successfully
  @returns  EFI_ABORTED     When tables not found or an error occurred, installation aborted
  @returns  EFI_LOAD_ERROR  When tables were found, but installation errored
**/
EFI_STATUS
EFIAPI
TryInstallXhyveAcpiTables(
    IN EFI_ACPI_TABLE_PROTOCOL       *AcpiProtocol
  )
{
  EFI_STATUS                                      Status;
  EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER    *RsdpPtr;

  UINTN                                            TableHandle;

  EFI_ACPI_DESCRIPTION_HEADER                      *Rsdt;
  EFI_ACPI_DESCRIPTION_HEADER                      *Xsdt;
  VOID                                             *CurrentTableEntry;
  UINTN                                            CurrentTablePointer;
  EFI_ACPI_DESCRIPTION_HEADER                      *CurrentTable;
  UINTN                                            Index;
  UINTN                                            NumberOfTableEntries;
  EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE        *Fadt2Table;
  EFI_ACPI_1_0_FIXED_ACPI_DESCRIPTION_TABLE        *Fadt1Table;
  EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE     *Facs2Table;
  EFI_ACPI_1_0_FIRMWARE_ACPI_CONTROL_STRUCTURE     *Facs1Table;
  EFI_ACPI_DESCRIPTION_HEADER                      *DsdtTable;

  // Trying to get Xhyve-generated ACPI Tables base address
  Status = GetXhyveAcpiRsdp(&RsdpPtr);
  if (Status == EFI_ABORTED) {
    DEBUG ((EFI_D_INFO, "%a: Xhyve generated ACPI RSDP not found\n", gEfiCallerBaseName));
    return EFI_ABORTED;
  }


  Fadt2Table  = NULL;
  Fadt1Table  = NULL;
  Facs2Table  = NULL;
  Facs1Table  = NULL;
  DsdtTable   = NULL;
  TableHandle = 0;
  NumberOfTableEntries = 0;

  //
  // If XSDT table is find, just install its tables.
  // Otherwise, try to find and install the RSDT tables.
  //
  if (RsdpPtr->XsdtAddress) {
    //
    // Retrieve the addresses of XSDT and
    // calculate the number of its table entries.
    //
    Xsdt = (EFI_ACPI_DESCRIPTION_HEADER *) (UINTN)
             RsdpPtr->XsdtAddress;
    NumberOfTableEntries = (Xsdt->Length -
                             sizeof (EFI_ACPI_DESCRIPTION_HEADER)) /
                             sizeof (UINT64);

    //
    // Install ACPI tables found in XSDT.
    //
    for (Index = 0; Index < NumberOfTableEntries; Index++) {
      //
      // Get the table entry from XSDT
      //
      CurrentTableEntry = (VOID *) ((UINT8 *) Xsdt +
                            sizeof (EFI_ACPI_DESCRIPTION_HEADER) +
                            Index * sizeof (UINT64));
      CurrentTablePointer = (UINTN) *(UINT64 *)CurrentTableEntry;
      CurrentTable = (EFI_ACPI_DESCRIPTION_HEADER *) CurrentTablePointer;

      //
      // Install the XSDT tables
      //
      Status = InstallAcpiTable (
                 AcpiProtocol,
                 CurrentTable,
                 CurrentTable->Length,
                 &TableHandle
                 );

      if (EFI_ERROR (Status)) {
        return Status;
      }

      //
      // Get the FACS and DSDT table address from the table FADT
      //
      if (!AsciiStrnCmp ((CHAR8 *) &CurrentTable->Signature, "FACP", 4)) {
        Fadt2Table = (EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE *)
                       (UINTN) CurrentTablePointer;
        Facs2Table = (EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE *)
                       (UINTN) Fadt2Table->FirmwareCtrl;
        DsdtTable  = (EFI_ACPI_DESCRIPTION_HEADER *) (UINTN) Fadt2Table->Dsdt;
      }
    }
  }
  else if (RsdpPtr->RsdtAddress) {
    //
    // Retrieve the addresses of RSDT and
    // calculate the number of its table entries.
    //
    Rsdt = (EFI_ACPI_DESCRIPTION_HEADER *) (UINTN)
             RsdpPtr->RsdtAddress;
    NumberOfTableEntries = (Rsdt->Length -
                             sizeof (EFI_ACPI_DESCRIPTION_HEADER)) /
                             sizeof (UINT32);

    //
    // Install ACPI tables found in XSDT.
    //
    for (Index = 0; Index < NumberOfTableEntries; Index++) {
      //
      // Get the table entry from RSDT
      //
      CurrentTableEntry = (UINT32 *) ((UINT8 *) Rsdt +
                            sizeof (EFI_ACPI_DESCRIPTION_HEADER) +
                            Index * sizeof (UINT32));
      CurrentTablePointer = *(UINT32 *)CurrentTableEntry;
      CurrentTable = (EFI_ACPI_DESCRIPTION_HEADER *) CurrentTablePointer;

      //
      // Install the RSDT tables
      //
      Status = InstallAcpiTable (
                 AcpiProtocol,
                 CurrentTable,
                 CurrentTable->Length,
                 &TableHandle
                 );

      if (EFI_ERROR (Status)) {
        return Status;
      }

      //
      // Get the FACS and DSDT table address from the table FADT
      //
      if (!AsciiStrnCmp ((CHAR8 *) &CurrentTable->Signature, "FACP", 4)) {
        Fadt1Table = (EFI_ACPI_1_0_FIXED_ACPI_DESCRIPTION_TABLE *)
                       (UINTN) CurrentTablePointer;
        Facs1Table = (EFI_ACPI_1_0_FIRMWARE_ACPI_CONTROL_STRUCTURE *)
                       (UINTN) Fadt1Table->FirmwareCtrl;
        DsdtTable  = (EFI_ACPI_DESCRIPTION_HEADER *) (UINTN) Fadt1Table->Dsdt;
      }
    }
  }

  //
  // Install the FACS table.
  //
  if (Fadt2Table) {
    //
    // FACS 2.0
    //
    Status = InstallAcpiTable (
               AcpiProtocol,
               Facs2Table,
               Facs2Table->Length,
               &TableHandle
               );
    if (EFI_ERROR (Status)) {
      return Status;
    }
  }
  else if (Fadt1Table) {
    //
    // FACS 1.0
    //
    Status = InstallAcpiTable (
               AcpiProtocol,
               Facs1Table,
               Facs1Table->Length,
               &TableHandle
               );
    if (EFI_ERROR (Status)) {
      return Status;
    }
  }

  //
  // Install DSDT table. If we reached this point without finding the DSDT,
  // then we're out of sync with the hypervisor
  //
  if (DsdtTable == NULL) {
    DEBUG ((DEBUG_ERROR, "%a: no DSDT found\n", __FUNCTION__));
    ASSERT (DsdtTable != NULL);
    CpuDeadLoop ();

    return EFI_LOAD_ERROR;
  }

  Status = InstallAcpiTable (
             AcpiProtocol,
             DsdtTable,
             DsdtTable->Length,
             &TableHandle
             );
  if (EFI_ERROR (Status)) {
    return Status;
  }

  DEBUG ((EFI_D_INFO, "%a: Xhyve generated ACPI RSDP found at 0x%p\n", gEfiCallerBaseName, RsdpPtr));
  return EFI_SUCCESS;
}
